<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

</body>
<script>
  // 先定义三个常量表示状态
  const PENDING = 'pending';
  const FULFILLED = 'fulfilled';
  const REJECTED = 'rejected';

  // 新建 MyPromise 类
  class MyPromise {
    constructor(executor) {
      // executor 是一个执行器，进入会立即执行
      // 并传入resolve和reject方法
      executor(this.resolve, this.reject);
      // 储存状态的变量，初始值是 pending
      this.status = PENDING;
      // 成功之后的值
      this.value = null;
      // 失败之后的原因
      this.reason = null;
      // 存储成功回调函数
      this.onFulfilledCallback = [];
      // 存储失败回调函数
      this.onRejectedCallback = [];
    }

    // 更改成功后的状态
    resolve = (value) => {
      // 只有状态是等待，才执行状态修改
      if (this.status === PENDING) {
        // 状态修改为成功
        this.status = FULFILLED;
        // 保存成功之后的值
        this.value = value;
        //resolve里面所有的成功的回调拿出来执行
        while (this.onFulfilledCallback.length) {
          //取出第一个元素，然后（）调用
          this.onFulfilledCallback.shift()(value)
        }

      }
    }

    // 更改失败后的状态
    reject = (reason) => {
      // 只有状态是等待，才执行状态修改
      if (this.status === PENDING) {
        // 状态成功为失败
        this.status = REJECTED;
        // 保存失败后的原因
        this.reason = reason;
        //resolve里面所有的成功的回调拿出来执行
        while (this.onRejectedCallback.length) {
          //取出第一个元素，然后（）调用
          this.onRejectedCallback.shift()(reason)
        }

      }
    }

    then(onFulfilled, onRejected) {
      return new MyPromise((resolve, reject) => {
        // 判断状态
        if (this.status === FULFILLED) {
          //获取成功回调函数的执行结果
          const suReason = onFulfilled(this.value);
          // 传入 resolvePromise 集中处理
          resolvePromise(suReason, resolve, reject)
        } else if (this.status === REJECTED) {
          // 调用失败回调，并且把原因返回
          onRejected(this.reason);
        } else if (this.status === PENDING) {
          //存储成功及失败回调
          this.onFulfilledCallback.push(onFulfilled);
          this.onRejectedCallback.push(onRejected);
        }
      })
    }
  }
  function resolvePromise(suReason, resolve, reject){
    //判断suReason是不是 MyPromise的实例对象
    if( suReason instanceof MyPromise){
      //执行suReason，调用then方法，是为了将状态改变为fulfilled 或者 rejected
      suReason.then(resolve, reject)
    }else{
      resolve(suReason)
    }
  }
  function other(){
    return new MyPromise((resolve, reject) =>{
      resolve("other")
    })
  }
  const promise = new MyPromise((resolve, reject) => {
    
    resolve('success')
  })

  promise.then(value => {
    console.log("1")
    console.log('resolve', value)
    return other()
  }).then(value => {
    console.log("2")
    console.log('resolve', value)
  })
</script>

</html>